package com.brainydroid.daydreaming.network;

import com.brainydroid.daydreaming.background.Logger;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.HttpClient;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.params.BasicHttpParams;
import org.apache.http.params.HttpConnectionParams;
import org.apache.http.params.HttpParams;
import org.apache.http.util.EntityUtils;

import android.os.AsyncTask;

import java.io.IOException;

public class HttpPostTask extends AsyncTask<HttpPostData, Void, Boolean> {

    private static String TAG = "HttpPostTask";

    private HttpClient client;
    private String serverAnswer;
    private HttpConversationCallback httpConversationCallback;

    @Override
    protected void onPreExecute() {
        Logger.v(TAG, "Doing pre-execution tasks: create client and set " +
                "connection timeout");

        HttpParams httpParams = new BasicHttpParams();
        HttpConnectionParams.setConnectionTimeout(httpParams,
                ServerConfig.NETWORK_TIMEOUT);
        client = new DefaultHttpClient(httpParams);
    }

    @Override
    protected Boolean doInBackground(HttpPostData... postDatas) {
        Logger.v(TAG, "Starting POST for data");

        try {
            HttpPostData postData = postDatas[0];
            httpConversationCallback = postData.getHttpConversationCallback();
            HttpPost httpPost = new HttpPost(postData.getPostUrl());
            StringEntity stringEntity = new StringEntity(postData.getPostString());

            httpPost.setHeader("Content-Type", postData.getContentType());
            httpPost.setEntity(stringEntity);

            HttpResponse response = client.execute(httpPost);
            HttpEntity resEntity = response.getEntity();

            if (resEntity != null) {
                try {
                    serverAnswer = EntityUtils.toString(resEntity);
                    Logger.v(TAG, "Answer successfully received and " +
                            "converted to String");
                } catch (IOException e) {
                    Logger.e(TAG, "Error converting response entity to " +
                            "String -> returning failure");
                    serverAnswer = null;
                    return false;
                }
            }
        } catch (ClientProtocolException e) {
            // FIXME: can we distinguish timeout from other errors? And report back to callback?
            Logger.e(TAG, "ClientProtocolException generated by POST -> " +
                    "returning failure");
            serverAnswer = null;
            return false;
        } catch (IOException e) {
            Logger.e(TAG, "IOException generated by POST -> returning " +
                    "failure");
            serverAnswer = null;
            return false;
        }

        return true;
    }

    @Override
    protected void onPostExecute(Boolean success) {
        if (httpConversationCallback != null) {
            Logger.v(TAG, "Calling back callback");
            httpConversationCallback.onHttpConversationFinished(success, serverAnswer);
        } else {
            Logger.e(TAG, "Work finished, but no callback to call back");
        }
    }

}
